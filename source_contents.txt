// File: src/App.tsx


import { LashTheAI } from './components/LashTheAI';
import { PromptModal } from './components/PromptModal';
import { TreeView } from './components/TreeView';
import { useTreeState } from './hooks/useTreeState';

function App() {
  const { tree, setTree, addChild, updateNodeContent, toggleLock, deleteNode, zoomIn } = useTreeState();


  return (
    <div className="min-h-screen bg-gray-50 p-8">
      <div className="w-full mx-auto">
        <h1 className="text-3xl font-bold text-gray-800 mb-8 text-center">Tree Builder</h1>
        <div className="bg-white rounded-xl shadow-sm p-8 min-h-[600px]">
          { tree && tree.children && tree.children.length > 1 ? <LashTheAI /> : <PromptModal setTree={setTree} />}
          <TreeView
            tree={tree}
            onAddChild={addChild}
            onUpdateContent={updateNodeContent}
            onToggleLock={toggleLock}
            onDelete={deleteNode}
            onZoomIn={zoomIn}
          />
        </div>
      </div>
    </div>
  )
}

export default App


// ----------------------------------------

// File: src/index.css

@tailwind base;
@tailwind components;
@tailwind utilities;
/* 
body {
    background-color: #000;
    color: #fff;
} */


// ----------------------------------------

// File: src/main.tsx

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


// ----------------------------------------

// File: src/vite-env.d.ts

/// <reference types="vite/client" />


// ----------------------------------------

// File: src/react.svg

<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

// ----------------------------------------

// File: src/LashTheAI.tsx

import { Sparkles, Hammer, HandMetal } from "lucide-react";
import { useAIAssistant } from "../hooks/useAIAssistant";
import { useTreeState } from "../hooks/useTreeState";


export function LashTheAI() {
  const { solveATaskWithAI } = useAIAssistant();
  const { tree } = useTreeState();

  return <div className="flex flex-col gap-2 h-64 items-center justify-center">
    <button className="flex items-center justify-center gap-2 bg-fuchsia-500 text-white p-2 px-4 rounded-md" onClick={async () => {
      const result = await solveATaskWithAI(tree, null);
      console.log("in LashTheAI - result: ", result);
    }}>
      <span className="text-sm">Lash</span>
      <Sparkles className="w-4 h-4" />
      <span className="text-sm">the</span>
      <Hammer className="w-4 h-4" />
      <span className="text-sm">AI</span>
      <HandMetal className="w-4 h-4" />
    </button>
  </div>
}

// ----------------------------------------

// File: src/PromptModal.tsx

import { Sparkles } from "lucide-react";
import { TreeNode } from "../types/tree";
import { useAIAssistant } from "../hooks/useAIAssistant";
import { useState } from "react";

export function PromptModal({ setTree }: { setTree: (tree: TreeNode) => void }) {
  const { generateTree } = useAIAssistant();
  const [prompt, setPrompt] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      const newTree = await generateTree(prompt);
      setTree(newTree);
    } catch (error) {
      console.error('Error generating tree:', error);
      // You might want to add error handling UI here
    } finally {
      setIsLoading(false);
    }
  };

  return <div className="flex flex-col gap-4 p-4 h-64">
    <form className="flex flex-col gap-4" onSubmit={handleSubmit}>
      <label htmlFor="prompt" className="text-lg font-bold">What do you want to develop?</label>
      <input type="text" id="prompt" className="p-2 border border-gray-300 rounded-md" onChange={(e) => setPrompt(e.target.value)} />
      <button 
        type="submit" 
        disabled={!prompt.trim() || isLoading}
        className="flex justify-center items-center text-center gap-2 bg-fuchsia-500 text-white p-2 rounded-md disabled:opacity-50 disabled:cursor-not-allowed"
      >
        <Sparkles className="w-4 h-4" />
        <p>{isLoading ? 'Generating...' : 'Generate'}</p>
      </button>
    </form>
  </div>;
}


// ----------------------------------------

// File: src/TreeNode.tsx

import React, { useState } from 'react';
import { Lock, Unlock, Plus, X, Search, Layers, Hammer } from 'lucide-react';
import { TreeNode as TreeNodeType } from '../types/tree';
import clsx from 'clsx';

interface TreeNodeProps {
  node: TreeNodeType;
  onAddChild: (parentId: string) => void;
  onUpdateContent: (nodeId: string, title: string, description: string) => void;
  onToggleLock: (nodeId: string) => void;
  onDelete: (nodeId: string) => void;
  onZoomIn: (nodeId: string) => void;
}

export function TreeNode({
  node,
  onAddChild,
  onUpdateContent,
  onToggleLock,
  onDelete,
  onZoomIn
}: TreeNodeProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editedTitle, setEditedTitle] = useState(node.title);
  const [editedDescription, setEditedDescription] = useState(node.description);

  const handleDoubleClick = () => {
    if (!node.isLocked) {
      setIsEditing(true);
      setEditedTitle(node.title);
      setEditedDescription(node.description);
    }
  };

  const handleContentSubmit = () => {
    onUpdateContent(node.id, editedTitle, editedDescription);
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleContentSubmit();
    }
    if (e.key === 'Escape') {
      setIsEditing(false);
      setEditedTitle(node.title);
      setEditedDescription(node.description);
    }
  };

  return (
    <div className="relative group">
      <div
        className={clsx(
          "p-4 bg-white border rounded-lg shadow-sm w-[250px]",
          node.isLocked
            ? "border-gray-400"
            : "border-blue-200 hover:border-blue-300",
          node.solved && "bg-teal-100",
          "transition-colors"
        )}
      >
        <div onDoubleClick={handleDoubleClick}>
          {isEditing ? (
            <div className="space-y-2 bg-">
              <input
                type="text"
                value={editedTitle}
                onChange={(e) => setEditedTitle(e.target.value)}
                onKeyDown={handleKeyDown}
                className="w-full px-2 py-1 border rounded text-sm"
                autoFocus
              />
              <textarea
                value={editedDescription}
                onChange={(e) => setEditedDescription(e.target.value)}
                onKeyDown={handleKeyDown}
                className="w-full px-2 py-1 border rounded text-sm resize-none"
                rows={2}
              />
            </div>
          ) : (
            <div className="min-h-[80px]">
              <h3 className="font-semibold mb-2 flex items-center gap-2">
                {node.title}
              </h3>
              <p className="text-sm text-gray-600">{node.description}</p>
            </div>
          )}
        </div>

        <div className="absolute top-2 right-2 flex gap-1">
          {!node.isLocked && (
            <>
              <button
                onClick={() => onZoomIn(node.id)}
                className="p-1 text-gray-500 hover:text-blue-500 rounded"
                title="View details"
              >
                <Search size={16} />
              </button>
              <button
                onClick={() => onDelete(node.id)}
                className="p-1 text-gray-500 hover:text-red-500 rounded"
                title="Delete node"
              >
                <X size={16} />
              </button>
            </>
          )}
          <button
            onClick={() => onToggleLock(node.id)}
            className={clsx(
              "p-1 text-gray-500 hover:text-blue-500 rounded",
              node.isLocked ? "text-gray-600" : "text-gray-500"
            )}
            title={node.isLocked ? "Unlock" : "Lock"}
          >
            {node.isLocked ? <Lock size={16} /> : <Unlock size={16} />}
          </button>
        </div>

        {node.isReachableByLowLevelDevelopers && (
          <div className="absolute -top-2 left-2 flex gap-1">
            <Hammer className="text-fuchsia-600" size={24} strokeWidth={2} />
          </div>
        )}

        <div className="absolute -bottom-8 left-1/2 -translate-x-1/2 z-10">
          <button
            onClick={() => onAddChild(node.id)}
            className="p-1 bg-white border rounded-full shadow-sm hover:bg-gray-50"
            title="Add child"
          >
            <Plus size={16} />
          </button>
        </div>
      </div>
    </div>
  );
}

// ----------------------------------------

// File: src/TreeView.tsx

import { TreeNode as TreeNodeComponent } from './TreeNode';
import { TreeNode as TreeNodeType } from '../types/tree';

interface TreeViewProps {
  tree: TreeNodeType;
  onAddChild: (parentId: string) => void;
  onUpdateContent: (nodeId: string, title: string, description: string) => void;
  onToggleLock: (nodeId: string) => void;
  onDelete: (nodeId: string) => void;
  onZoomIn: (nodeId: string) => void;
}

export function TreeView({
  tree,
  onAddChild,
  onUpdateContent,
  onToggleLock,
  onDelete,
  onZoomIn
}: TreeViewProps) {

  const renderNode = (node: TreeNodeType) => (
    <div key={node.id} className="flex flex-col items-center">
      <div className="relative">
        <TreeNodeComponent
          node={node}
          onAddChild={onAddChild}
          onUpdateContent={onUpdateContent}
          onToggleLock={onToggleLock}
          onDelete={onDelete}
          onZoomIn={onZoomIn}
        />
        {node.children && node.children.length > 0 && (
          <div className="absolute w-px h-16 border-l-2 border-gray-200 left-1/2 top-full" />
        )}
      </div>
      {node.children && node.children.length > 0 && (
        <div className="flex gap-8 mt-16">
          <div className="flex gap-8 pt-16 border-2 px-2 pb-16 bg-fuchsia-400/20 rounded-lg ">
            {node.children.map(childNode => renderNode(childNode))}
          </div>
        </div>
      )}
    </div>
  );

  return (
    <div className="w-full min-w-auto h-full inline-flex items-center p-8 overflow-x-auto">
      {renderNode(tree)}
    </div>
  );
}


// ----------------------------------------

// File: src/useAIAssistant.ts

import { useCallback } from 'react';
import { TreeNode } from '../types/tree';
import { pushTreeToGithub, getRepoContents, commitAssistantResponse } from '../services/github';
import { generateNodeContent, generateTreeContent, solveATaskContent } from '../services/openai';


export function useAIAssistant() {
  const generateContent = useCallback(async (
    node: TreeNode,
    parentNode: TreeNode | null,
    prompt: string
  ) => {
    try {
      return await generateNodeContent(node, parentNode, prompt);
    } catch (error) {
      console.error('Failed to generate content:', error);
      throw error;
    }
  }, []);

  const generateTree = useCallback(async (prompt: string) => {
    return await generateTreeContent(null, null, prompt);
  }, []);

  const saveToGithub = useCallback(async (content: any) => {
    try {
      await pushTreeToGithub(content);
    } catch (error) {
      console.error('Failed to save to GitHub:', error);
      throw error;
    }
  }, []);


  const solveATaskWithAI = useCallback(async (
    node: TreeNode | null,
    parentNode: TreeNode | null,
  ) => {
    const repo = await getRepoContents();
    const solutionToCommit = await solveATaskContent(repo, node, parentNode);
    console.log("in useAIAssistant - solutionToCommit: ", solutionToCommit);
    const assistantResponse = await commitAssistantResponse(solutionToCommit);
    console.log("in useAIAssistant - assistantResponse: ", assistantResponse);
    return assistantResponse;
  }, []);


  return {
    generateContent,
    generateTree,
    saveToGithub,
    solveATaskWithAI
  };
}


// ----------------------------------------

// File: src/useTreeState.ts

import { useState, useCallback } from 'react';
import { TreeNode } from '../types/tree';
import { generateId } from '../utils/helpers';
import { useAIAssistant } from './useAIAssistant';
import { findNode, lockParentNodes } from '../utils/tree-utils';

export function useTreeState() {
  const [tree, setTree] = useState<TreeNode>({
    id: generateId(),
    title: 'First Task',
    description: 'Root node description',
    isLocked: false,
    children: null,
    parentId: null
  });

  // const { generateContent, saveToGithub } = useAIAssistant();
  const { generateContent } = useAIAssistant();

  const generateWithAI = useCallback(async (parentId: string, aiPrompt?: string) => {
    const parentNode = findNode(tree, parentId);
    if (!parentNode) return;
    return await generateContent(parentNode, null, aiPrompt || '');
  }, [generateContent, tree]);

  const addChild = useCallback(async (parentId: string) => {
    try {
      const parentNode = findNode(tree, parentId);
      if (!parentNode) return;
      const newNode: TreeNode = {
        id: generateId(),
        title: 'New Node',
        description: 'Add a description',
        isLocked: false,
        children: null,
        parentId
      };

      setTree((current) => {
        function updateNode(node: TreeNode): TreeNode {
          if (node.id === parentId) {
            return {
              ...node,
              children: node.children ? [...node.children, newNode] : [newNode],
            };
          }

          return {
            ...node,
            children: node.children ? node.children.map(updateNode) : null,
          };
        }

        const updatedTree = updateNode(current);
        // saveToGithub(updatedTree).catch(console.error);
        return updatedTree;
      });
    } catch (error) {
      console.error('Failed to add child:', error);
    }
  }, [tree]);

  const updateNodeContent = useCallback((nodeId: string, title: string, description: string) => {
    setTree((current) => {
      function updateNode(node: TreeNode): TreeNode {
        if (node.id === nodeId) {
          return {
            ...node,
            title,
            description,
          };
        }

        return {
          ...node,
          children: node.children ? node.children.map(updateNode) : null,
        };
      }

      return updateNode(current);
    });
  }, []);

  const toggleLock = useCallback((nodeId: string) => {
    setTree((current) => {
      function updateNode(node: TreeNode): TreeNode {
        if (node.id === nodeId) {
          const newLockState = !node.isLocked;
          return {
            ...node,
            isLocked: newLockState
          };
        }

        return {
          ...node,
          children: node.children ? node.children.map(updateNode) : null,
        };
      }

      return updateNode(current);
    });


  }, []);

  const deleteNode = useCallback((nodeId: string) => {
    setTree((current) => {
      function updateNode(node: TreeNode): TreeNode {
        if (node.children) {
          const filteredChildren = node.children.filter(child => child.id !== nodeId);
          if (filteredChildren.length !== node.children.length) {
            return {
              ...node,
              children: filteredChildren.length > 0 ? filteredChildren : null,
            };
          }
          return {
            ...node,
            children: node.children.map(updateNode),
          };
        }
        return node;
      }

      return updateNode(current);
    });
  }, []);

  const zoomIn = useCallback((nodeId: string) => {
    const node = findNode(tree, nodeId);
    if (node) {
      // do something with the card to expand and show details
    }
  }, [tree]);

  return { tree, setTree, addChild, generateWithAI, updateNodeContent, toggleLock, deleteNode, zoomIn };
}

// ----------------------------------------

// File: src/github.ts

import { Octokit } from 'octokit';
import { TreeNode } from '../types/tree';

const octokit = new Octokit({
  auth: import.meta.env.VITE_GITHUB_TOKEN
});

const REPO_OWNER = 'FelipeAndresBascunanMorales';
const REPO_NAME = 'junior-legion-assistant-3';
const BRANCH = 'main';

interface TreeData {
  tree: TreeNode;
  timestamp: number;
  version: string;
}

interface ContentData {
  type: 'repository_contents',
  base_path: 'src/',
  files: [{
    path: string,
    content: string
  }],
  task_solved: "task identifier"
}

 // this code is working but just push the tree to github
export async function pushTreeToGithub(tree: TreeNode): Promise<void> {
  try {
    const treeData: TreeData = {
      tree,
      timestamp: Date.now(),
      version: '1.0.0'
    };

    // Get the latest commit SHA
    const { data: ref } = await octokit.rest.git.getRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `heads/${BRANCH}`
    });

    const { data: commit } = await octokit.rest.git.getCommit({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      commit_sha: ref.object.sha
    });

    // Create a new blob with the tree data
    const { data: blob } = await octokit.rest.git.createBlob({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      content: btoa(JSON.stringify(treeData, null, 2)),
      encoding: 'base64'
    });

    // Create a new tree
    const { data: newTree } = await octokit.rest.git.createTree({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      base_tree: commit.tree.sha,
      tree: [{
        path: 'tree-data.json',
        mode: '100644',
        type: 'blob',
        sha: blob.sha
      }]
    });

    // Create a new commit
    const { data: newCommit } = await octokit.rest.git.createCommit({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      message: 'Update tree data',
      tree: newTree.sha,
      parents: [ref.object.sha]
    });

    // Update the reference
    await octokit.rest.git.updateRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `heads/${BRANCH}`,
      sha: newCommit.sha
    });
  } catch (error) {
    console.error('Failed to push to GitHub:', error);
    throw new Error('Failed to push to GitHub');
  }
}

// this code push the changes on files according to the task solved
export async function commitAssistantResponse(assistantResponse, branch = "junior-partner-contributor") {
  const { files, task_solved } = assistantResponse;
  
  try {
    // 1. Get the latest commit SHA
    const { data: ref } = await octokit.rest.git.getRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `heads/${branch}`,
    });
    const latestCommitSha = ref.object.sha;

    // 2. Create a new branch for these changes
    const newBranch = `feature/${task_solved}`;
    await octokit.rest.git.createRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `refs/heads/${newBranch}`,
      sha: latestCommitSha,
    });

    console.log("in commitAssistantResponse - newBranch: ", newBranch);
    // 3. Create blobs for each file
    const fileBlobs = await Promise.all(
      files.map(async file => {
        const { data: blob } = await octokit.rest.git.createBlob({
          owner: REPO_OWNER,
          repo: REPO_NAME,
          content: file.content,
          encoding: "utf-8",
        });

        return {
          path: file.path,
          sha: blob.sha,
          mode: "100644", // regular file
          type: "blob",
        };
      })
    );

    // 4. Create a tree
    const { data: tree } = await octokit.rest.git.createTree({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      base_tree: latestCommitSha,
      tree: fileBlobs,
    });

    // 5. Create a commit
    const { data: commit } = await octokit.rest.git.createCommit({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      message: `feat: ${task_solved}`,
      tree: tree.sha,
      parents: [latestCommitSha],
    });

    // 6. Update the branch reference
    await octokit.rest.git.updateRef({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      ref: `heads/${newBranch}`,
      sha: commit.sha,
    });

    // 7. Create a pull request
    const { data: pr } = await octokit.rest.pulls.create({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      title: `Feature: ${task_solved}`,
      head: newBranch,
      base: branch,
      body: `Automated changes by assistant for task: ${task_solved}`,
    });

    return {
      success: true,
      pullRequest: pr.html_url,
      branch: newBranch,
    };

  } catch (error) {
    console.error('Error during commit process:', error);
    return {
      success: false,
      error: error.message,
    };
  }
}

export async function getRepoContents() {
  // Get the tree recursively
  const { data: { tree } } = await octokit.rest.git.getTree({
    owner: "FelipeAndresBascunanMorales",
    repo: "junior-legion-assistant-3",
    tree_sha: "junior-partner-contributor", // or your branch
    recursive: "1"
  });

  // Filter for src/ files
  const srcFiles = tree.filter(item => 
    item.type === "blob" && 
    item.path?.startsWith("src/")
  );

  // Get content for each file
  const contents = await Promise.all(
    srcFiles.map(async file => {
      const { data } = await octokit.rest.git.getBlob({
        owner: "FelipeAndresBascunanMorales",
        repo: "junior-legion-assistant-3",
        file_sha: file.sha ?? ''
      });

      return {
        path: file.path,
        content: Buffer.from(data.content, 'base64').toString()
      };
    })
  );

  return contents;
}

// With rate limiting and batching
export async function handleLargeRepo() {
  const { data: { tree } } = await octokit.rest.git.getTree({
    owner: "FelipeAndresBascunanMorales",
    repo: "junior-legion-assistant-3",
    tree_sha: "junior-partner-contributor",
    recursive: "1"
  });

  const srcFiles = tree.filter(item => 
    item.type === "blob" && 
    item.path?.startsWith("src/")
  );

  // Process in batches
  const batchSize = 10;
  const results = [];

  for (let i = 0; i < srcFiles.length; i += batchSize) {
    const batch = srcFiles.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(async file => {
        const { data } = await octokit.rest.git.getBlob({
          owner: "FelipeAndresBascunanMorales",
          repo: "junior-legion-assistant-3",
          file_sha: file.sha ?? ''
        });

        return {
          path: file.path,
          content: Buffer.from(data.content, 'base64').toString()
        };
      })
    );
    results.push(...batchResults);
    
    // Optional: Add delay between batches
    if (i + batchSize < srcFiles.length) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  return results;
}

// ----------------------------------------

// File: src/openai.ts

import OpenAI from 'openai';
import { TreeNode } from '../types/tree';
import { z } from 'zod';

const PROJECT_MANAGER_ASSISTANT_ID = "asst_uoqTiJO5E9UAEY2f3ZJNIi8L";
const SENIOR_DEVELOPER_ASSISTANT_ID = "asst_5krcIPLblqj9rjKFB3rkjnLF";

const openai = new OpenAI({
  apiKey: import.meta.env.VITE_OPENAI_API_KEY,
  dangerouslyAllowBrowser: true
});


const nodeUpdateSchema = z.object({
  title: z.string(),
  description: z.string(),
  action: z.enum(['create', 'update', 'delete'])
});

type NodeUpdate = z.infer<typeof nodeUpdateSchema>;

export async function generateTreeContent(
  currentNode: TreeNode | null,
  tree: TreeNode | null,
  prompt: string
): Promise<TreeNode> {
  // wake up the assistant
  const assistant = await openai.beta.assistants.retrieve(PROJECT_MANAGER_ASSISTANT_ID);

  // create a thread
  const thread = await openai.beta.threads.create();

  const message = await openai.beta.threads.messages.create(thread.id, {
    role: "user",
    content: prompt
  });

  // create a run
  const run = await openai.beta.threads.runs.createAndPoll(thread.id, {
    assistant_id: assistant.id,
  });

  if (run.status === 'completed') {
    const responseData = await openai.beta.threads.messages.list(run.thread_id);  
    const newTree = JSON.parse(responseData.data[0].content[0].text.value);
    console.log("responseData: ", responseData);
    console.log("newTree (parsed): ", newTree);
    return newTree;
  } else {
    console.log(run.status);
    throw new Error(`OpenAI run failed with status: ${run.status}`);
  }
}

export async function generateNodeContent(
  currentNode: TreeNode,
  parentNode: TreeNode | null,
  prompt: string
): Promise<NodeUpdate> {
  const systemPrompt = `You are a helpful AI assistant that helps users manage and organize information in a tree structure.
Current context:
- Node title: ${currentNode.title}
- Node description: ${currentNode.description}
${parentNode ? `- Parent node title: ${parentNode.title}
- Parent node description: ${parentNode.description}` : ''}

Generate a response that includes a title and description for the node, considering the user's input and the current context.
The response should be in JSON format with the following structure:
{
  "title": "string",
  "description": "string",
  "action": "create" | "update" | "delete"
}`;

  const completion = await openai.chat.completions.create({
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: prompt }
    ],
    model: 'gpt-4-turbo-preview',
    response_format: { type: 'json_object' }
  });

  const response = completion.choices[0].message.content;
  if (!response) throw new Error('No response from OpenAI');

  try {
    const parsedResponse = JSON.parse(response);
    return nodeUpdateSchema.parse(parsedResponse);
  } catch (error) {
    console.error('Failed to parse OpenAI response:', error);
    throw new Error('Invalid response format from OpenAI');
  }
}

export async function solveATaskContent(
  contents: any,
  node: TreeNode | null,
  parentNode: TreeNode | null,
) {

  const fileStructure = {
    type: 'repository_contents',
    base_path: 'src/',
    files: contents.map((file: any) => ({
      path: file.path,
      content: file.content
    }))
  };

  // Create a vector store including our two files.
  let vectorStore = await openai.beta.vectorStores.create({
    name: "repository_contents",
  });

  const fileBatch = await openai.beta.vectorStores.fileBatches.uploadAndPoll(vectorStore.id, fileStructure)
  console.log("fileBatch: ", fileBatch);
  console.log("fileBatch.status: ", fileBatch.status);

  await openai.beta.assistants.update(SENIOR_DEVELOPER_ASSISTANT_ID, {
    tool_resources: { file_search: { vector_store_ids: [vectorStore.id] } },
  });
  console.log("fileBatch.status after assistant update: ", fileBatch.status);

  const thread = await openai.beta.threads.create();

  const prompt = `
    check the following tree and take one of the most reachable tasks and solve it.
    ${JSON.stringify(node)}
  `;
  console.log("prompt: ", prompt);
  
  const message = await openai.beta.threads.messages.create(thread.id, {
    role: "user",
    content: prompt
  });

  console.log("message: ", message);
  console.log("fileBatch.status after message creation: ", fileBatch.status);
  const run = await openai.beta.threads.runs.createAndPoll(thread.id, {
    assistant_id: SENIOR_DEVELOPER_ASSISTANT_ID,
  });

  if (run.status === 'completed') {
    const responseData = await openai.beta.threads.messages.list(run.thread_id);
    console.log("responseData: ", responseData);
    return responseData.data[0].content[0].text.value;
  }

}

// ----------------------------------------

// File: src/tree.ts

export interface TreeNode {
  id: string; // Unique identifier for the task.
  title: string; // Brief task title.
  description: string; // Short purpose and expected outcome of the task.
  order?: number; // Execution sequence across all tasks.
  solved?: boolean; // Default set to false.
  isLocked?: boolean; // Default set to false.
  parentId?: string | null; // Parent task identifier.
  mustBeCodedInCodeBase?: boolean; // Indicates whether the task requires coding in the main project.
  levelOfGranularity?: number; // Rating from 0 (too complex) to 10 (completely approachable).
  isReachableByLowLevelDevelopers?: boolean; // [true/false] for junior developer suitability.
  children?: TreeNode[] | null; // Nested subtasks if any.
}

export interface Position {
  x: number;
  y: number;
}

// ----------------------------------------

// File: src/helpers.ts

export function generateId(): string {
  return Math.random().toString(36).substr(2, 9);
}

export function calculateNodePosition(
  parentX: number,
  parentY: number,
  direction: 'left' | 'right' | 'bottom'
): { x: number; y: number } {
  const SPACING = 150;
  
  switch (direction) {
    case 'left':
      return { x: parentX - SPACING, y: parentY };
    case 'right':
      return { x: parentX + SPACING, y: parentY };
    case 'bottom':
      return { x: parentX, y: parentY + SPACING };
  }
}

// ----------------------------------------

// File: src/tree-utils.ts

import { TreeNode } from '../types/tree';

export function findNode(tree: TreeNode, id: string): TreeNode | null {
  if (tree.id === id) return tree;
  
  if (tree.children) {
    for (const child of tree.children) {
      const found = findNode(child, id);
      if (found) return found;
    }
  }
  
  return null;
}

export function lockParentNodes(tree: TreeNode, nodeId: string): TreeNode {
  function updateNodes(node: TreeNode): TreeNode {
    if (node.children) {
      const updatedChildren = node.children.map(child => {
        const updatedChild = updateNodes(child);
        if (updatedChild.isLocked && node.id !== nodeId) {
          return { ...node, isLocked: true };
        }
        return updatedChild;
      });
      return { ...node, children: updatedChildren };
    }
    return node;
  }
  
  return updateNodes(tree);
}

// ----------------------------------------

